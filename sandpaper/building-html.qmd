---
title: "Building HTML"
from: markdown+emoji
---

## Introduction

Building HTML in The Workbench is a process that is isolated from rendering
R *Markdown* to *Markdown*. There are three general steps to building the HTML
files:

1. **render** the HTML using `pandoc` with our custom lua filters (which transform
   our special fenced-divs and flattens relative links)
2. **post-process** the HTML using {xml2} to further refine and translate
   elements that we cannot achieve through Lua filters. It is here that we do
   things like adding heading anchors, removing instructor notes for learner
   view, etc.
3. **apply {varnish} templates** by passing [global
   variables](https://carpentries.github.io/sandpaper/dev/articles/data-flow.html)
   and HTML to {pkgdown}. This is where the metadata and most of the
   translations are applied. 

## Rendering HTML

The first step of the pipeline is to render the HTML from *Markdown* (in the
`site/built` folder) using pandoc with our custom lua filters. This is entirely
encapsulated within the function
[`render_html()`](https://carpentries.github.io/sandpaper/reference/render_html.html):

```{mermaid}
flowchart TB
    IN["site/built/FILE.md"]
    TMP["/tmp/tempfile.html"]
    OUT[/"R Object"\]
    pandoc{{"pandoc"}}
    LUA["sandpaper/../lesson.lua"]

    IN --> pandoc --> TMP
    TMP -->|"readLines()"| OUT
    LUA -->|"construct_pandoc_args()"| pandoc
```


`render_html()` is called by all of the pages which **need to render content
from markdown**:


```{r}
#| label: render-html
#| echo: false
#| eval: !expr Sys.getenv("CI", "false") != "true"
#| message: false
#| cache: true
toc <- Sys.time()
tmp <- "tmp.html"
flow::flow_view_uses(sandpaper:::render_html, out = tmp)
res <- webshot2::webshot(tmp, "render-html.png", zoom = 2)
unlink(tmp)
tic <- Sys.time()
cat(paste("time elapsed:", format(tic - toc)))
```

![](render-html.png)

The HTML that is rendered from `render_html()` is not standalone and expected to
be insert into the `<main>` tags of [HTML
boilderplate](https://jerryjones.dev/2018/01/30/basic-html-boilerplate-structure/).
Luckily, `render_html()` _is_ a standalone function. This means that you do not
need to prepare anything other than a document for it to render. Here's an
example rendering basic *Markdown* to HTML as a character string. Let's say we
had a single markdown document that just showed:

```markdown
I can write in **Markdown** and $\\LaTeX$ :joy_cat:
```

When rendered, it would look like this:


> I can write in **Markdown** and $\\LaTeX$ :joy_cat:

To test the rendering, we can create a temporary file on the fly and use
`render_html()` to render it.

```{r}
#| label: render-show
#| eval: false
tmp <- tempfile()
writeLines("I can write in **Markdown** and $\\LaTeX$ :joy_cat:", tmp)
html_text <- sandpaper:::render_html(tmp)
```

The `html_text` variable contains a string of length 1 that contains the
rendered HTML from the markdown. 

```{r}
#| label: render-simple
#| echo: false
#| results: 'asis'
tmp <- tempfile()
writeLines("I can write in **Markdown** and $\\LaTeX$ :joy_cat:", tmp)
html_text <- sandpaper:::render_html(tmp)
html <- xml2::read_html(html_text)
writeLines(c("```html", html_text, "```"))
```

### Working with the Output

for all of the functions that use `render_html()` you will find this general
pipeline: `file_path |> render_html() |> xml2::read_html()`. 

```{r}
#| label: render-html-practical-demo
#| eval: false
html_text <- render_html(file_path)
if (html_text == "") {
  html <- xml2::read_html("<p></p>")
} else {
  html <- xml2::read_html(html_text)
}
```

You can then use it to explore and manipulate the elements using good ol' XPath
synatax :cowboy_hat_face: Yee haw!

::: {.callout-tip}

#### :hand: Wait just a rootin' tootin' minute!

 - :weary: We have HTML, why are we using XML to parse it? 
 - :cowboy_hat_face: Well, pardner, just like cowpolk can rustle up cows, sheep,
   goats, and even cats, XPath is a language that can be used to rustle up ANY
   sort of pointy-syntax markup like HTML, XML, SVG, and even
   [CSL](https://en.wikipedia.org/wiki/Citation_Style_Language). 
 - :astonished: That's a good point!
 - :cowboy_hat_face: Fastest pun in the West!
 - :wink:
:::


```{r}
#| label: xpath-mf
#| comment: '##'
print(html)
xml2::xml_find_all(html, ".//p/strong")
xml2::xml_find_all(html, ".//p/span[@class='emoji']")
```

The HTML can also be _copied_ by converting it to a character and re-reading it
as XML (yes, this is legitimately the fastest way to do this).

::: {.callout-note}

See [the {pegboard} intro to XML about the memory of XML
objects](https://carpentries.github.io/pegboard/articles/intro-xml.html#the-memory-of-xml-objects)
for a reason _why_ you want to copy XML documents this way.

:::

```{r}
html2 <- xml2::read_html(as.character(html))
```


From here, the nodes get sent to `fix_nodes()` so that they can be
post-processed. 

## Post-processing with XPath

Before the HTML can be passed to the template, it needs to be tweaked a bit.
There are two reasons why we would need to tweak the HTML:

 - We want to add a feature that is not supported in pandoc (or at least older
   versions)
 - We need to structurally rearrange pandoc defaults to match our template


To do this, we read in the HTML with `xml2::read_html()` and then manipulate it
using the sandpaper internal function `fix_nodes()`, which is called by the
following functions:

```{r}
#| label: fix-nodes-uses
#| echo: false
#| eval: !expr Sys.getenv("CI", "false") != "true"
#| message: false
#| cache: true
toc <- Sys.time()
tmp <- "tmp.html"
flow::flow_view_uses(sandpaper:::fix_nodes, out = tmp)
res <- webshot2::webshot(tmp, "fix-nodes-uses.png", zoom = 2)
unlink(tmp)
tic <- Sys.time()
cat(paste("time elapsed:", format(tic - toc)))
```

![](fix-nodes-uses.png)


In turn, `fix_nodes()` will call this cascade of XML manipulating functions:


```{r}
#| label: fix-nodes-deps
#| echo: false
#| eval: !expr Sys.getenv("CI", "false") != "true"
#| message: false
#| cache: true
toc <- Sys.time()
tmp <- "tmp.html"
flow::flow_view_deps(sandpaper:::fix_nodes, out = tmp, show_imports = "none")
res <- webshot2::webshot(tmp, "fix-nodes-deps.png", zoom = 2)
tic <- Sys.time()
unlink(tmp)
cat(paste("time elapsed:", format(tic - toc)))
```

![](fix-nodes-deps.png)


I will show the effects of each of these funtions one by one, but first, here's
a couple of functions that will help me demonstrate so I don't have to keep
retyping an copying/pasting:

```{r}
#| label: post-process-tango
render_and_parse <- function(txt) {
  tmp <- tempfile()
  writeLines(txt, tmp)
  return(xml2::read_html(sandpaper:::render_html(tmp)))
}

print_html <- function(html, xpath = ".//body/*") {
  writeLines(as.character(xml2::xml_find_all(html, xpath)))
}
```


### Translation of Overview Card

The Overview card is produced by the Lua filter, combining the `objectives` and
`questions` fenced divs into one entity:

```{r}
#| label: overview-show
ovr <- "
::: objectives

- one

:::
::: questions

- one?

:::"

render_and_parse(ovr) |> 
  print_html()
```

The _only_ purpose for `translate_overview()` is to translate the entities for
this card into different languages, so if we use it in an English context,
nothing happens, but if we use it in a _Japanese_ context, the the translation
appears:

```{r}
#| label: translate-overview
withr::with_language("ja", {
  render_and_parse(ovr) |> 
    sandpaper:::translate_overview() |> 
    print_html()
})
```

### Headings

Headings in The Workbench need a couple of things done:

0. The parent div needs to be a `<section>` tag
1. They need [anchor
   links](https://amberwilson.co.uk/blog/are-your-anchor-links-accessible/)
   added to the headings (we took ours from {pkdown})
2. The section element needed to be a `section-heading` class and there needed
   to be an `<hr>` element underneath the `<h2>` tags.

Behold!

```{r}
#| label: fix-headings
heads <- "
## Heading 2 {#i-am-a-section-link}

### Heading 3 

This is in a section, but it's not a section

## Heading 2

This is a new section
"
render_and_parse(heads) |> print_html()
render_and_parse(heads) |> sandpaper:::fix_headings() |> print_html()
```


### Accordions

The only thing that happens with accordions is that they get translated:

```{r}
#| label: fix-accordions
accord <- "
::: instructor

drink water

:::
"
render_and_parse(accord) |> print_html(".//h3/text()")
withr::with_language("ja", {
  render_and_parse(accord) |> 
    sandpaper:::fix_accordions() |> 
    print_html(".//h3/text()")
})
```

### Callouts

Callouts need to have translations applied and ids adjusted:

```{r}
#| label: fix-callouts
keyps <- "
::: keypoints

 - hydrate

:::"
render_and_parse(keyps) |> print_html()
render_and_parse(keyps) |> sandpaper:::fix_callouts() |> print_html()
```

The translations are also applied:

```{r}
#| label: fix-callouts-too
withr::with_language("ja", {
  render_and_parse(keyps) |> 
    sandpaper:::fix_callouts() |> 
    print_html(".//h3/text()")
})
```

### Codeblocks

Codeblocks have a phantom H3 attached

````{r}
#| label: fix-codeblocks
codes <- "
```r
cat('mouse')
```"
render_and_parse(codes) |> print_html()
render_and_parse(codes) |> sandpaper:::fix_codeblocks() |> print_html()
````

### Figures

Figures need semantic HTML `<figure>`, not `<div>` and lone images with no
captions should still be figures.

```{r}
#| label: fix-figures
figs <- "
![](lone-img.png){alt='tumbleweed'}

![Just Sayin', Breakfast Plums, So Cold](papa-eating-plums.png){alt='an empty icebox, plums gone'}
"
render_and_parse(figs) |> print_html()
render_and_parse(figs) |> sandpaper:::fix_figures() |> print_html()
```

### Setup Link

When someone writes the link to `setup.html`, it needs to be transmogrified to
be `index.html#setup`

```{r}
#| label: fix-setup
stp <- "
[setup](../learners/setup.html) 

with [macOS](../learners/setup.html#macos)"

render_and_parse(stp) |> print_html()
render_and_parse(stp) |> sandpaper:::fix_setup_link() |> print_html()
```


## Applying {varnish} templating

All HTML files get funneled into `pkgdown::render_page()` through `build_html()`


```{r}
#| label: render-page
#| echo: false
#| eval: !expr Sys.getenv("CI", "false") != "true"
#| cache: true
toc <- Sys.time()
tmp <- "tmp.html"
flow::flow_view_uses(pkgdown::render_page, "sandpaper", out = tmp)
res <- webshot2::webshot(tmp, "render-page.png", zoom = 2)
unlink(tmp)
tic <- Sys.time()
cat(paste("time elapsed:", format(tic - toc)))
```

![](render-page.png)
